# 統合 (Integration)

## 重点ポイント

- いかなる代償を払ってもデータベースの統合を避ける
- REST と RPC を理解し、REST をリクエスト／レスポンス統合
- オーケストレーションよりコレオグラフィを選ぶ
- ポステル法則を理解し、耐性のあるリーダー (Tolerant Readers) を使って、破壊的変更を避け、バージョンが必要ないようにする
- ユーザインタフェースを合成レイアと考える

## 理想的な統合技術の探索

マイクロサービスとマイクロサービス対話する方法はたくさん選択肢がある。SOAP、XML-RPC、REST、Protocol Buffers、選択する前に、**その技術から何を得たい**のを考えましょう

- **破壊的変更を回避する**
- **API を技術非依存にする**
- **コンシューマにとって単純なサービスにする**
- **内部の実装詳細を隠す**

## 共有データベース **絶対ダメの例**

- DB は事実上は大規模な共有 API
- **DB 統合は、強い凝集性と疎結合の両方を失う**

## 同期と非同期 **非同期お勧め**

- 同期通信とは
  - リモートサーバに呼び出しを行い、サーバは操作完了まで呼び出しをブロックする
- 非同期通信とは
  - 呼び出し側は操作完了するのを待たずにレスポンスが戻り、操作完了気にしないこともある
  - 低遅延が必要なときにとても有効
- 通信モードが２つ
  - リクエスト (Request) / レスポンス (Response)
  - イベントベース (Event)

## オーケストレーション (Orchestration) と コレオグラフィ (Choreography) **コレオグラフィお勧め**

- オーケストレーションの欠点
  - 中央監督機関になりすぎる
- コレオグラフィ
  - 非同期でイベントを発行させ、通知することができる
  - イベント処理が適切に実行されたかを監視し追跡する、追加の作業が必要
  - 監視システムの構築が必要
  - 疎結合で柔軟性あり

## リモートプロシージャコール (RPC) (お勧めしない)

RPC はローカルで呼び出しを行い、別のリモートサーバでそのお呼びだしを実行する

- 技術的結合
  - RPC 技術の相互運用に制約あり
- ローカル呼び出しはリモート呼び出しとは異なる
  - 分散システムはネットワーク信頼性がないと前提
- 脆弱性
  - ビルドごと、バイナリが変わる
  - クライアントとサーバを別々デポロイできない
- RPC はひどいか
  - Protocal Buffers は同時リリースの罪を軽減する (Google は典型)

## REST

- REST と HTTP
  - 相性が良い
- アプリケーション状態エンジンとしてのハイパーメディア (HATEOAS)
  - Hypermedia As The Engine Of Application State
  - お勧めしない

```xml
<album>
  <name>Give Blood</name>
  <link ref="/artist" href="/artist/theBrakes" />
  <description>
    Awesome, short, brutish, funny and loud. Must buy!
  </description>
  <link rel="/instantpurchase" href="/instantPurchase/1234" />
</album>
```

- JSON か、XML か、他の何かか
  - HTTP 上動作するサービスは JSON の方が人気
- HTTP 上の REST の欠点
  - REST Application Protocol のクライアントスタブは、RPC のように簡単に生成できない

## 非同期イベントベース連携の実装

- 技術選択
  - RabbitMQ など
- 非同期アーキテクチャの複雑さ
  - トランザクション型キューを使用しており、ワーカが停止すると、Request lock timeout、リクエストがキューに戻され
    - 別のワークも停止してしまう
    - 最終的に、メッセージ病院 (失敗したメッセージの送り先キュー) が必要

## 状態マシンとしてのサービス (お勧めしない)

## Reactive Extentions (お勧めしない)

## マイクロサービスの世界における DRY とコード再利用のリスク

DRY (Don't Repeat Yourself)は、システムの振る舞いと知識の重複を回避すること
**どこでも使える共有ライブラリは見かけによらず危険です**

- クライアントライブラリ **絶対やめてください**
  - 密結合になりがち
  - サーバ変更された場合、複数クライアント修正しなければ

## バージョニング

- 最大限の先送り
  - 破壊的変更を避けることが、影響を減らす最善の方法
- 破壊的変更の早期の把握
  - コンシューマ駆動契約で早期検出に可能
- セマンティックバージョニングの利用
  - MAJOR.MINOR.PATCH
- 異なるエンドポイントの共存
  - 新旧インタフェース共存させる方法
  - ３つ以上の共存はお勧めしない
    - 管理負担が大きい
  - v1 エンドポイントへの全てのリクエストを v2 リクエストに変換
- 複数サービスバージョンの同時使用
  - BlueGreen Deployment
  - Canary Deployment

## ユーザインタフェース

- API 合成 (お勧めしない)
  - デバイスごとにレスポンスを調整できない
  - 誰が作成するのか
- UI 部品合成 (お勧めしない)
  - UX の一貫性を保証する必要がある
  - ページに収まらないかも
- フロントエンド向けのバックエンド (BFF)
  - Backends For Frontends

## サードパーティ Software との統合

- 制御の欠如
- カスタマイズ
- 統合スパゲティ
- 想い通りにする
- ストラングラー パターン
